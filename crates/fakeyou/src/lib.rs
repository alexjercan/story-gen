use anyhow::Result;
use bevy::tasks::AsyncComputeTaskPool;
use bevy::{prelude::*, tasks::Task};
use fakeyou_api::tts::*;
use fakeyou_api::util::tts::*;
use fakeyou_api::*;
use futures_lite::future;
use std::collections::HashMap;

// This component is used to run the FakeYou call on another thread
#[derive(Component)]
struct FakeYouTask(Task<Result<Vec<u8>>>);

// The plugin will listen for this event to set the openai key
#[derive(Event, Debug)]
pub struct InputApiKeyEvent(pub String);

// The plugin will listen for this event to trigger set the tts options
#[derive(Event, Debug)]
pub struct InputOptionsEvent(pub TTSOptions);

// The plugin will listen for this event to trigger the FakeYou call
#[derive(Event, Debug)]
pub struct InputSayEvent {
    pub name: String,
    pub text: String,
}

// This event is triggered when tts is generated by FakeYou
#[derive(Event, Debug)]
pub struct CreatedTTSEvent(pub Result<Handle<AudioSource>>);

// This resource is used to store the FakeYou request state
#[derive(Resource, Debug, Default, Deref, DerefMut)]
struct FakeYouTTSOptions(TTSOptions);

#[derive(Debug, Clone, Default)]
pub struct TTSOptions {
    pub voices: HashMap<String, String>,
}

// This resource holds the OpenAI API key
#[derive(Resource, Debug, Deref, DerefMut, Clone)]
struct FakeYouAuth(Option<Auth>);

#[derive(Default)]
pub struct FakeYouPlugin {
    auth: Option<Auth>,
}

impl FakeYouPlugin {
    pub fn from_env() -> Self {
        Self {
            auth: Auth::from_env().ok(),
        }
    }
}

impl Plugin for FakeYouPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<InputApiKeyEvent>()
            .add_event::<InputOptionsEvent>()
            .add_event::<InputSayEvent>()
            .add_event::<CreatedTTSEvent>()
            .insert_resource(FakeYouAuth(self.auth.clone()))
            .init_resource::<FakeYouTTSOptions>()
            .add_systems(
                Update,
                (
                    handle_apikey_event,
                    handle_input_options,
                    handle_input_action,
                    poll_fakeyou_task,
                ),
            );
    }
}

fn handle_apikey_event(
    mut ev_input_apikey: EventReader<InputApiKeyEvent>,
    mut auth: ResMut<FakeYouAuth>,
) {
    ev_input_apikey.iter().for_each(|ev| {
        auth.0 = Some(Auth::new(&ev.0));
    });
}

fn handle_input_options(
    mut ev_input_options: EventReader<InputOptionsEvent>,
    mut options: ResMut<FakeYouTTSOptions>,
) {
    ev_input_options.iter().for_each(|ev| {
        options.0 = ev.0.clone();
    });
}

fn handle_input_action(
    mut commands: Commands,
    mut ev_input_say: EventReader<InputSayEvent>,
    options: Res<FakeYouTTSOptions>,
    auth: Res<FakeYouAuth>,
) {
    ev_input_say.iter().for_each(|ev| {
        let name = ev.name.clone();
        let text = ev.text.clone();
        let voices = options.voices.clone();

        let auth = auth.clone().0.unwrap_or_default();

        let thread_pool = AsyncComputeTaskPool::get();
        let task = thread_pool.spawn(async move {
            let fakeyou = FakeYou::new(auth, FAKEYOU_API_URL);

            let name = voices
                .get(&name)
                .ok_or_else(|| anyhow::anyhow!("Name {} not found in voices list", name))?;
            let text = &text;

            let inference_body = InferenceBody::new(name, text);

            fakeyou
                .create_tts_task(&inference_body)
                .map(|t| t.bytes)
                .map_err(|e| anyhow::anyhow!(e))
        });

        commands.spawn(FakeYouTask(task));
    });
}

fn poll_fakeyou_task(
    mut commands: Commands,
    mut tasks: Query<(Entity, &mut FakeYouTask)>,
    mut ev_created_tts: EventWriter<CreatedTTSEvent>,
    mut assets: ResMut<Assets<AudioSource>>,
) {
    let Some((entity, mut task)) = tasks.iter_mut().next() else { return };

    if let Some(audio) = future::block_on(future::poll_once(&mut task.0)) {
        let audio = audio.map(|bytes| {
            let audio_source = AudioSource {
                bytes: bytes.as_slice().into(),
            };

            assets.add(audio_source)
        });

        ev_created_tts.send(CreatedTTSEvent(audio));

        commands.entity(entity).despawn();
    }
}

use bevy::tasks::AsyncComputeTaskPool;
use bevy::{prelude::*, tasks::Task};
use fakeyou_api::tts::*;
use fakeyou_api::util::tts::*;
use fakeyou_api::*;
use futures_lite::future;
use std::collections::HashMap;
use std::fmt::Display;

// The FakeYouResult type is used to wrap the result of the FakeYou call
pub type FakeYouResult<T> = Result<T, Error>;

#[derive(Debug, Clone)]
pub enum Error {
    RequestError(String),
    TtsError(String),
}

impl From<fakeyou_api::Error> for Error {
    fn from(err: fakeyou_api::Error) -> Self {
        match err {
            fakeyou_api::Error::RequestError(err) => Error::RequestError(err),
        }
    }
}

impl Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self {
            Error::RequestError(err) => write!(f, "Request error: {}", err),
            Error::TtsError(err) => write!(f, "TTS error: {}", err),
        }
    }
}

// This component is used to run the FakeYou call on another thread
#[derive(Component)]
struct FakeYouTask(Task<FakeYouResult<Vec<u8>>>);

// The plugin will listen for this event to trigger set the tts options
#[derive(Event, Debug)]
pub struct InputOptionsEvent(pub TTSOptions);

#[derive(Debug, Clone)]
pub struct SayAction {
    pub name: String,
    pub text: String,
}

// The plugin will listen for this event to trigger the FakeYou call
#[derive(Event, Debug)]
pub struct InputSayEvent(pub SayAction);

// This event is triggered when tts is generated by FakeYou
#[derive(Event, Debug)]
pub struct CreatedTTSEvent(pub FakeYouResult<Handle<AudioSource>>);

#[derive(Debug, Clone, Default)]
pub struct TTSOptions {
    pub names: HashMap<String, String>,
}

// This resource is used to store the FakeYou request state
#[derive(Resource, Debug, Default, Deref, DerefMut)]
struct FakeYouTTSOptions(TTSOptions);

impl FakeYouTTSOptions {
    fn set_options(&mut self, options: TTSOptions) {
        self.0 = options;
    }
}

pub struct FakeYouPlugin;

impl Plugin for FakeYouPlugin {
    fn build(&self, app: &mut App) {
        app.add_event::<InputOptionsEvent>()
            .add_event::<InputSayEvent>()
            .add_event::<CreatedTTSEvent>()
            .init_resource::<FakeYouTTSOptions>()
            .add_systems(
                Update,
                (handle_input_options, handle_input_action, poll_fakeyou_task),
            );
    }
}

fn handle_input_options(
    mut ev_input_options: EventReader<InputOptionsEvent>,
    mut options: ResMut<FakeYouTTSOptions>,
) {
    ev_input_options.iter().for_each(|ev| {
        options.set_options(ev.0.clone());
    });
}

fn handle_input_action(
    mut commands: Commands,
    mut ev_input_say: EventReader<InputSayEvent>,
    options: Res<FakeYouTTSOptions>,
) {
    ev_input_say.iter().for_each(|ev| {
        let message = ev.0.clone();
        let names = options.names.clone();

        let thread_pool = AsyncComputeTaskPool::get();
        let task = thread_pool.spawn(async move {
            let fakeyou = FakeYou::default();

            let name = names.get(&message.name).ok_or_else(|| {
                Error::TtsError(format!("Name {} not found in names list", message.name))
            })?;
            let text = &message.text;

            let inference_body = InferenceBody::new(name, text);

            fakeyou
                .create_tts_task(&inference_body)
                .map(|t| t.bytes)
                .map_err(Error::from)
        });

        commands.spawn(FakeYouTask(task));
    });
}

fn poll_fakeyou_task(
    mut commands: Commands,
    mut tasks: Query<(Entity, &mut FakeYouTask)>,
    mut ev_created_tts: EventWriter<CreatedTTSEvent>,
    mut assets: ResMut<Assets<AudioSource>>,
) {
    let Some((entity, mut task)) = tasks.iter_mut().next() else { return };

    if let Some(audio) = future::block_on(future::poll_once(&mut task.0)) {
        let audio = audio.map(|bytes| {
            let audio_source = AudioSource {
                bytes: bytes.as_slice().into(),
            };

            assets.add(audio_source)
        });

        ev_created_tts.send(CreatedTTSEvent(audio.clone()));

        commands.entity(entity).despawn();
    }
}
